<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Drawing INGRID</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
			}
			#renderer {
				width: 100%;
				height: 75vh;
				position: relative;
				border: 1px solid #bcc3c6;
				border-radius: 2px;
			}
			canvas {
				z-index: 1;
				padding: 0;
				margin: auto;
				display: block;
				position: absolute;
				border: 1px solid #bcc3c6;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
			}
			.panel, .flip {
				padding: 5px;
				text-align: center;
				border: solid 1px #c3c3c3;
			}
			.panel {
				padding: 50px;
				display: none;
			}
			#hint {
				height: 17vh;
				border: 1px solid #bcc3c6;
				border-radius: 2px;
				overflow-y: auto;
			}
			<!--Modal-->
			.modal {
				display: none;
				position: fixed;
				z-index: 1;
				left: 0;
				top: 0;
				width: 100%; 
				height: 100%;
				overflow: auto;
				background-color: rgb(0,0,0); 
				background-color: rgba(0,0,0,0.4); 
			}
			.modal-content {
				background-color: #fefefe;
				margin: 15% auto; /* 15% from the top and centered */
				padding: 20px;
				border: 1px solid #888;
				width: 80%; /* Could be more or less, depending on screen size */
			}
			.close {
				color: #aaa;
				float: right;
				font-size: 28px;
				font-weight: bold;
			}
			.close:hover,
			.close:focus {
				color: black;
				text-decoration: none;
				cursor: pointer;
			}
			<!--Input Box for naming nodes-->
			#nodeNameInput {
				display: none;
				z-index: 2;
				position: absolute;
			}
			<!--Animation Buttons-->
			#previous {
				display: none;
				z-index: 2;
				position: absolute;
			}
			#next {
				display: none;
				z-index: 2;
				position: absolute;
			}
			#replay {
				display: none;
				z-index: 2;
				position: absolute;
			}
			#skip {
				display: none;
				z-index: 2;
				position: absolute;
			}
			#solution-counter {
				display: none;
				z-index: 2;
				position: absolute;
				width: 80px;
				height: 50px;
				text-align: center;
				font-size: 20px;
			}
			#color-picker {
				display: none;
				z-index: 2;
				width: 220px;
				height: 40px;
				border: 1px black solid;
				background-color: white;
				padding: 4px;
				position: absolute;
			}
			#color-counter {
				float: left;
				margin: 5px 5px 0 0;
			}
			.my-tiny-button {
				height: 25px;
				width: 25px;
				padding: 0px;
			}
			.my-med-button {
				display: none;
				z-index: 2;
				height: 50px;
				width: 50px;
				padding: 10px;
			}
			.text-label {
				color: #fff;
				font-family: "Fira Mono", Monaco, "Andale Mono", "Lucida Console", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace;
				margin: -5px 0 0 15px;
				pointer-events:none;
			}
		</style>
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
		<link rel='stylesheet' href='../js/spectrum.css'/>
	</head>
	<body>
		<!--Navbar-->
		<nav class="navbar navbar-default">
			<div class="container-fluid">
				<div class="nav-bar-header">
					<button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#bs-example-navbar-collpase-1" aria-expanded="undt">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<a class="navbar-brand" href="#">
						INGRID<sup>2</sup>
					</a>
				</div>
				<div id="bs-example-navbar-collapse-1" class="collapse navbar-collapse">
					<ul class="nav navbar-nav">
						<li><a href="/">Draw</a></li>
					</ul>
					<ul class="nav navbar-nav navbar-right">
						<li><a href="#">Staff</a></li>
					</ul>
				</div>
			</div>
		</nav>

		<div class="container-fluid">
			<div class="row">
				<!--Renderer and Hint box-->
				<div class="col-md-9">
					<div class="row">
						<div id="renderer">
						</div>
					</div>
					<div class="row">
						<p id="hint" class="bg-info"></p>
					</div>
				</div>
				<!--Options-->
				<div class="col-md-3">
					<div class="row">
						<div class="flip" id="flip-1">Enter Node and Edge Set</div>
						<div class="panel" id="panel-1">
							<form>
								<div class="form-group">
									<label for="nodes">Node Set:</label>
									<input type="text" class="form-control" id="nodes">
								</div>
								<div class="form-group">
									<label for="edges">Edge Set:</label>
									<input type="text" class="form-control" id="edges">
								</div>
								<button type="button" class="btn btn-default" id="submit-set">Submit</button>
							</form>
						</div>
					</div>
					<div class="row">
						<div class="flip" id="flip-2">Enter Degree Sequence</div>
						<div class="panel" id="panel-2">
							<form>
								<div class="form-group">
									<label for="degree-seq">Degree Sequence:</label>
									<input type="text" class="form-control" id="degree-seq">
								</div>
								<button type="button" class="btn btn-default" id="submit-seq">Submit</button>
							</form>
						</div>
					</div>
					<div class="row">
						<div class="flip" id="flip-3">Draw</div>
						<div class="panel" id="panel-3">
							<button type="button" class="btn btn-default" onclick="drawNodeMode()">Draw Node</button>
							<button type="button" class="btn btn-default" onclick="drawEdgeMode()">Draw Edge</button>
							<button type="button" class="btn btn-default" onclick="deleteNodeMode()">Delete Node</button>
							<button type="button" class="btn btn-default" onclick="deleteEdgeMode()">Delete Edge</button>
							<button type="button" class="btn btn-default" onclick="moveNodeMode()">Move Node</button>
							<button type="button" class="btn btn-default" onclick="renameNodeMode()">Rename Node</button>
							<button type="button" class="btn btn-default" onclick="clearGraphAct()">Clear Graph</button>
						</div>
					</div>
					<div class="row">
						<div class="flip" id="flip-4">Graph Functions</div>
						<div class="panel" id="panel-4">
							<button type="button" class="btn btn-default" onclick="edgeContractionMode()">Edge Contraction</button>
							<button type="button" class="btn btn-default" onclick="complementAct()">Complement</button>
							<button type="button" class="btn btn-default" onclick="">Planarity</button>
							<button type="button" class="btn btn-default" onclick="eulerianCycleMode()">Eulerian Cycles</button>
							<button type="button" class="btn btn-default" onclick="hamiltonianCycleMode()">Hamiltonian Cycles</button>
							<button type="button" class="btn btn-default" onclick="hamiltonianPathMode()">Hamiltonian Paths</button>
							<button type="button" class="btn btn-default" onclick="graphColorMode()">Graph Coloring</button>
						</div>
					</div>
					<div class="row">
						<div class="flip" id="flip-5">Save</div>
						<div class="panel" id="panel-5">
							<button type="button" class="btn btn-default" id="save-file">Save File</button>
							<button type="button" class="btn btn-default" id="save-Link">Save a link</button>
						</div>
					</div>
				</div>
			</div>
		</div>
		
		<!--Modal to give options for the PDF-->
		<div id="SaveModal" class="modal"  class="modal fade" role="dialog">

			<div class="modal-content">
				<div class="modal-header">
					<span class="close">&times;</span>
					<h4 class="modal-title">Save</h4>
				</div>
				<div class="modal-body">
					<form class="form" id="Save-Form">
						File Type: <br>
						<div class="radio">
							<input type="radio" name="FileType" id="PDF" value="PDF"checked>PDF<br>
						</div>
						<div class="radio">
							<input type="radio" name="FileType" id="PNG" value="PNG">PNG<br>
						</div>
						<div class="radio">
							<input type="radio" name="FileType" id="JPG" value="JPG">JPG<br>
						</div>
						Save file as:
						<input type="text" class="form-control" name="Filename" id="Filename" value="graph.pdf"><br>
						<button type="button" class="btn btn-default" id="save-File-Set">Save</button>
					</form>
				</div>
			</div>
		</div>
		
		<!--Input Field for naming nodes-->
		<div class="form-group col-xs-1" id="nodeNameInput">
			<input type="text" class="form-control" id="nodeName">
		</div>
		
		<!--Buttons dealing with animation-->
		<button type="button" class="btn btn-default" id="previous" onclick="ANIMATIONCONTROL.prevAnimation()"><i class="material-icons">navigate_before</i></button>
		<button type="button" class="btn btn-default" id="next" onclick="ANIMATIONCONTROL.nextAnimation()"><i class="material-icons">navigate_next</i></button>
		<button type="button" class="btn btn-default" id="skip" onclick="ANIMATIONCONTROL.skipAnimation()"><i class="material-icons">skip_next</i></button>
		<button type="button" class="btn btn-default" id="replay" onclick="ANIMATIONCONTROL.replayAnimation()"><i class="material-icons">replay</i></button>
		<p id="solution-counter"></p>
		
		<!--Color Picker-->
		<div id="color-picker"> 
			<p id="color-counter">Color #1:<p>
			<input type='text' id="custom" />
			<button type="button" class="btn btn-default my-tiny-button" onclick="ANIMATIONCONTROL.prevColor()"><i class="material-icons">navigate_before</i></button>
			<button type="button" class="btn btn-default my-tiny-button" onclick="ANIMATIONCONTROL.nextColor()"><i class="material-icons">navigate_next</i></button>
			<button type="button" class="btn btn-default my-tiny-button" onclick="ANIMATIONCONTROL.go()">GO</button>
		</div>
		
		<!--Go Button-->
		<button type="button" class="btn btn-default my-med-button" id="go" onclick="ANIMATIONCONTROL.go()">GO</button>
		
		
		<script src="../js/three.js"></script>
		<script src="../js/OrbitControls.js"></script>
		<script src="../js/download.js"></script>
		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.2/jspdf.debug.js"></script>
		
		
		<script src='../js/spectrum.js'></script>
		
		<script id="webWorker" type="javascript/worker">
			self.onmessage = function(e) {			
				obj = JSON.parse(e.data);
				
				var firstOpportunity = false;
				var potential = false;
				var newContext = {};
				
				if(obj.type === "EC") {
					//Backup context
					obj = obj.context;
					
					//Create current context
					var circuit = obj.circuit.slice();
					var edgesVisited = obj.edgesVisited.slice();
					var unusedEdges = obj.unusedEdges.slice();
					var start = obj.start;
					var last = obj.last;
					var matrix = obj.matrix;
					var GRAPH = JSON.parse(obj.GRAPH);
				
					//This condition should never be false
					while(circuit.length <= GRAPH.nodes.length) {
						//Either new or a mini cycle was completed, so start off the next cycle
						if(start === last) {
							//Explore the leftover adjacent edges
							for(var i = 0; i < GRAPH.nodes.length; i++) {
								if(matrix[start][GRAPH.nodes[i].id] !== null 
								&& !circuit.includes(GRAPH.nodes[i].id)
								&& !edgesVisited.includes(matrix[start][GRAPH.nodes[i].id])) {
									
									potential = true;
									//Update current context to continue
									if(firstOpportunity === false) {
										circuit.push(GRAPH.nodes[i].id);
										last = GRAPH.nodes[i].id;
										unusedEdges[start] = unusedEdges[start] === undefined || unusedEdges[start] === 
											null ? GRAPH.nodes[findIndexOfNode(GRAPH.nodes, start)].degree - 1 : unusedEdges[start] - 1;
										unusedEdges[last] = unusedEdges[last] === undefined || unusedEdges[last] === 
											null ? GRAPH.nodes[findIndexOfNode(GRAPH.nodes, last)].degree - 1 : unusedEdges[last] - 1;
										edgesVisited.push(matrix[start][last]);
										firstOpportunity = true;
									}
									//Copy backup context and update for new path and queue it up
									else {
										newContext = copyECContext(obj);
										newContext.circuit.push(GRAPH.nodes[i].id);
										newContext.last = GRAPH.nodes[i].id;
										newContext.unusedEdges[newContext.start] = newContext.unusedEdges[start] === undefined || newContext.unusedEdges[newContext.start] === 
											null ? GRAPH.nodes[findIndexOfNode(GRAPH.nodes,newContext.start)].degree - 1 : newContext.unusedEdges[newContext.start] - 1;
										newContext.unusedEdges[newContext.last] = newContext.unusedEdges[newContext.last] === undefined || newContext.unusedEdges[newContext.last] === 
											null ? GRAPH.nodes[findIndexOfNode(GRAPH.nodes,newContext.last)].degree - 1 : newContext.unusedEdges[newContext.last] - 1;
										newContext.edgesVisited.push(matrix[newContext.start][newContext.last]);
										
										self.postMessage(ECReport(newContext, "Incomplete"));
									}
								}
							}
							
							if(potential === false) {
								return;
							}
							
							potential = false;
						}
						
						//Update backup context and reset bool
						obj = updateECContext({circuit, edgesVisited, matrix, unusedEdges, start, last});
						firstOpportunity = false;
						
						//Builds path until start node is encountered
						while(start !== last) {
							//Chooses next node, checks if the start is encountered or not
							for(var i = 0; i < GRAPH.nodes.length; i++) {
								if(matrix[last][GRAPH.nodes[i].id] !== null 
								&& start === GRAPH.nodes[i].id 
								&& !edgesVisited.includes(matrix[last][GRAPH.nodes[i].id])) {
									
									potential = true;
								
									if(firstOpportunity === false) {
										edgesVisited.push(matrix[last][GRAPH.nodes[i].id]);
										last = start;
										unusedEdges[circuit[circuit.length - 1]]--;
										unusedEdges[start]--;
										firstOpporunity = true;
									}
									else {
										newContext = copyECContext(obj);
										newContext.edgesVisited.add(matrix[newContext.last][GRAPH.nodes[i].id]);
										newContext.last = newContext.start;
										newContext.unusedEdges[circuit[circuit.length - 1]]--;
										newContext.unusedEdges[newContext.start]--;
									}
								}
								else if(matrix[last][GRAPH.nodes[i].id] !== null 
								&& !edgesVisited.includes(matrix[last][GRAPH.nodes[i].id])) {
								
									potential = true;
								
									if(firstOpportunity === false) {
										edgesVisited.push(matrix[last][GRAPH.nodes[i].id]);
										last = GRAPH.nodes[i].id;
										circuit.push(last);
										unusedEdges[last] = unusedEdges[last] === undefined || unusedEdges[last] ===
											null ? GRAPH.nodes[findIndexOfNode(GRAPH.nodes, last)].degree - 1 : unusedEdges[last] - 1;
										unusedEdges[circuit[circuit.length - 2]]--;
										firstOpporunity = true;
									}
									else {
										newContext = copyECContext(obj);
										newContext.edgesVisited.push(matrix[newContext.last][GRAPH.nodes[i].id]);
										newContext.last = GRAPH.nodes[i].id;
										newContext.circuit.push(newContext.last);
										newContext.unusedEdges[newContext.last] = newContext.unusedEdges[newContext.last] === undefined || newContext.unusedEdges[newContext.last] ===
											null ? GRAPH.nodes[findIndexOfNode(GRAPH.nodes, newContext.last)].degree - 1 : newContext.unusedEdges[newContext.last] - 1;
										newContext.unusedEdges[circuit[circuit.length - 2]]--;
										
										self.postMessage(ECReport(newContext, "Incomplete"));
									}
								}
								
								firstOpportunity = false;
								obj = updateECContext({circuit, edgesVisited, matrix, unusedEdges, start, last});
							}
						}
						
						start = null;
						
						//Finds first node with unused edges
						for(var i = 0; i < GRAPH.nodes.length; i++) {
							if((unusedEdges[GRAPH.nodes[i].id] !== undefined || 
								unusedEdges[GRAPH.nodes[i].id] !== null) &&
								unusedEdges[GRAPH.nodes[i].id] !== 0) {
								if(firstOpportunity === false) {
									start = last = GRAPH.nodes[i].id;
								}
								else {
									newContext = copyECContext(obj);
									newContext.start = newContext.last = GRAPH.nodes[i].id;
									
									self.postMessage(ECReport(newContext, "Incomplete"));
								}
							}
						};
						
						falseOpportunity = false;
						obj = updateECContext({circuit, edgesVisited, matrix, unusedEdges, start, last});
						
						//This is the eulerian circuit
						if(start === null) {
							circuit.push(last);
							obj = updateECContext({circuit, edgesVisited, matrix, unusedEdges, start, last});
							self.postMessage(ECReport(obj,"Complete"));
							return;
						}
						
						//Rotates circuit for the new starting node
						while(start != circuit[0]) {
							circuit.push(circuit.shift());
						}
						circuit.push(last);
						obj = updateECContext({circuit, edgesVisited, matrix, unusedEdges, start, last});
						
						console.log(obj);
						
						if(circuit.length > GRAPH.nodes.length) {
							break;
						}
					}
				}
				//Hamiltonian Cycle
				else if(obj.type === "HC") {
					//Backup context
					obj = obj.context;
					
					//This path's context
					var circuit = obj.circuit.slice();
					var nodesVisited = obj.nodesVisited.slice();
					var matrix = obj.matrix;
					var GRAPH = JSON.parse(obj.GRAPH);
					
					//Select first node, if just starting
					if(circuit.length === 0) {
						for(var i = 0; i < GRAPH.nodes.length; i++) {
							//Update current context to continue
							if(firstOpportunity === false) {
								circuit.push(GRAPH.nodes[i].id);
								nodesVisited.push(GRAPH.nodes[i].id);
								
								firstOpportunity = true;
							}
							//Copy backup context and update for new path and queue it up
							else {
								newContext = copyHCContext(obj);
								newContext.circuit.push(GRAPH.nodes[i].id);
								newContext.nodesVisited.push(GRAPH.nodes[i].id);
								
								self.postMessage(HCReport(newContext, "Incomplete"));
							}
						}
					}
					
					//Update backup context and reset bool
					obj = copyHCContext({circuit: circuit, nodesVisited: nodesVisited, matrix: matrix, GRAPH: JSON.stringify(GRAPH)});
					firstOpportunity = false;
					
					//Build up the path until failute or success
					while(nodesVisited.length !== GRAPH.nodes.length) {
						//Go through all possibilities
						for(var i = 0; i < GRAPH.nodes.length; i++) {
							//Discount invalid paths (not adjacent or already on path)
							if(matrix[circuit[circuit.length - 1]][GRAPH.nodes[i].id] !== null && 
							!nodesVisited.includes(GRAPH.nodes[i].id)) {
								//Update current context to continue
								if(firstOpportunity === false) {
									circuit.push(GRAPH.nodes[i].id);
									nodesVisited.push(GRAPH.nodes[i].id);
									
									firstOpportunity = true;
									potential = true;
								}
								//Copy backup context and update for new path and queue it up
								else {
									newContext = copyHCContext(obj);
									newContext.circuit.push(GRAPH.nodes[i].id);
									newContext.nodesVisited.push(GRAPH.nodes[i].id);
									
									self.postMessage(HCReport(newContext, "Incomplete"));
								}
							}
						}
						
						//Current path cannot be continued, kill this cycle
						if(potential === false) {
							break;
						}
						
						//Reset potential and backup context for next step
						potential = false;
						firstOpportunity = false;
						obj = copyHCContext({circuit: circuit, nodesVisited: nodesVisited, matrix: matrix, GRAPH: JSON.stringify(GRAPH)});
					}
					
					//Almost done! It's path not a cycle!
					if(nodesVisited.length === GRAPH.nodes.length) {
						//Success! Can complete cycle
						if(matrix[circuit[0]][circuit[circuit.length - 1]] !== null){
							newContext = copyHCContext(obj);
							self.postMessage(HCReport(newContext, "Complete"));
						}
					}
					
					//This path was a failure, leave it to die
				}
				//Hamiltonian Path
				else if(obj.type === "HP") {
					//Backup context
					obj = obj.context;
					
					//This path's context
					var path = obj.path.slice();
					var nodesVisited = obj.nodesVisited.slice();
					var matrix = obj.matrix;
					var GRAPH = JSON.parse(obj.GRAPH);
					
					//Select first node, if just starting
					if(path.length === 0) {
						for(var i = 0; i < GRAPH.nodes.length; i++) {
							//Update current context to continue
							if(firstOpportunity === false) {
								path.push(GRAPH.nodes[i].id);
								nodesVisited.push(GRAPH.nodes[i].id);
								
								firstOpportunity = true;
							}
							//Copy backup context and update for new path and queue it up
							else {
								newContext = copyHPContext(obj);
								newContext.path.push(GRAPH.nodes[i].id);
								newContext.nodesVisited.push(GRAPH.nodes[i].id);
								
								self.postMessage(HPReport(newContext, "Incomplete"));
							}
						}
					}
					
					//Update backup context and reset bool
					obj = copyHPContext({path: path, nodesVisited: nodesVisited, matrix: matrix, GRAPH: JSON.stringify(GRAPH)});
					firstOpportunity = false;
					
					//Build up the path until failute or success
					while(nodesVisited.length !== GRAPH.nodes.length) {
						//Go through all possibilities
						for(var i = 0; i < GRAPH.nodes.length; i++) {
							//Discount invalid paths (not adjacent or already on path)
							if(matrix[path[path.length - 1]][GRAPH.nodes[i].id] !== null && 
							!nodesVisited.includes(GRAPH.nodes[i].id)) {
								//Update current context to continue
								if(firstOpportunity === false) {
									path.push(GRAPH.nodes[i].id);
									nodesVisited.push(GRAPH.nodes[i].id);
									
									firstOpportunity = true;
									potential = true;
								}
								//Copy backup context and update for new path and queue it up
								else {
									newContext = copyHPContext(obj);
									newContext.path.push(GRAPH.nodes[i].id);
									newContext.nodesVisited.push(GRAPH.nodes[i].id);
									
									self.postMessage(HPReport(newContext, "Incomplete"));
								}
							}
						}
						
						//Current path cannot be continued, kill this cycle
						if(potential === false) {
							break;
						}
						
						//Reset potential and backup context for next step
						potential = false;
						firstOpportunity = false;
						obj = copyHPContext({path: path, nodesVisited: nodesVisited, matrix: matrix, GRAPH: JSON.stringify(GRAPH)});
					}
					
					//This path was a success
					if(nodesVisited.length === GRAPH.nodes.length) {
						newContext = copyHPContext(obj);
						self.postMessage(HPReport(newContext, "Complete"));
					}	
					
					//This path was a failure, leave it to die
				}
				//Graph Coloring
				else if(obj.type === "GC") {
					//Backup context
					obj = obj.context;
					
					//This path's context
					var nodeColors = obj.nodeColors;
					var nodesLeft = obj.nodesLeft;
					var currentColor = obj.currentColor;
					var changeColor = obj.changeColor;
					var matrix = obj.matrix;
					var GRAPH = JSON.parse(obj.GRAPH);
					var colors = obj.colors;
					
					var giveUp = false;
					
					var candidateNode = {};
					
					//Setup
					if(nodeColors.length === 0 && nodesLeft.length === 0) {
						for(var i = 0; i < GRAPH.nodes.length; i++) {
							nodesLeft.push({
								id: GRAPH.nodes[i].id,
								degree: GRAPH.nodes[i].degree,
							})
						}
						
						changeColor = true;
						nodesLeft.sort(compareDegrees);
						
						//Update backup context
						obj = copyGCContext({nodeColors: nodeColors, nodesLeft: nodesLeft, currentColor: currentColor,
							changeColor: changeColor, matrix: matrix, GRAPH: JSON.stringify(GRAPH), colors: colors });
					}
					
					while(nodesLeft.length !== 0) {
						//Selecting a new color for incomplete coloring
						if(changeColor === true){
							
							candidateNode = nodesLeft[0].id;
							
							//Selects nodes with same degree for other paths
							for(var i = 1; i < nodesLeft.length && nodesLeft[i].degree === nodesLeft[0].degree; i++) {
								newContext = copyGCContext(obj);
								newContext.currentColor++;
								newContext.changeColor = false;
								newContext.nodeColors.push({id: newContext.nodesLeft[i].id, color: colors[newContext.currentColor]});
								newContext.nodesLeft.splice(i, 1);
								self.postMessage(GCReport(newContext, "Incomplete"));
							}
							
							//Update current context
							currentColor++;
							nodesLeft.shift();
							nodeColors.push({id: candidateNode, color: colors[currentColor]});
							changeColor = false;
							
							//Update backup context
							obj = copyGCContext({nodeColors: nodeColors, nodesLeft: nodesLeft, currentColor: currentColor,
								changeColor: changeColor, matrix: matrix, GRAPH: JSON.stringify(GRAPH), colors: colors });
							
							//Explore the possibilities
							for(var i = 0; i < obj.nodesLeft.length; i++) {
								if(matrix[candidateNode][obj.nodesLeft[i].id] === null) {
									if(firstOpportunity === false) {
										nodeColors.push({id: nodesLeft[i].id, color: colors[currentColor]});
										nodesLeft.splice(i, 1);
										firstOpportunity = true;
									}
									else {
										newContext = copyGCContext(obj);
										newContext.currentColor = currentColor;
										newContext.nodeColors.push({id: newContext.nodesLeft[i].id, color: colors[newContext.currentColor]});
										newContext.nodesLeft.splice(i, 1);
										newContext.changeColor = false;
										self.postMessage(GCReport(newContext, "Incomplete"));
									}
								}
							}
							
							if(firstOpportunity === true) {
								nodesLeft.splice(i, 1);
							}
							
							//Update backup context
							obj = copyGCContext({nodeColors: nodeColors, nodesLeft: nodesLeft, currentColor: currentColor,
								changeColor: changeColor, matrix: matrix, GRAPH: JSON.stringify(GRAPH), colors: colors });
							firstOpportunity = false;
						}
						//Continuing the same color
						else {
							giveUp = true;
							//Explore the opportunities
							for(var i = 0; i < obj.nodesLeft.length; i++) {
								
								if(checkAdjNodesColor(obj.nodesLeft[i], obj.nodeColors, matrix, colors[currentColor])) {
									giveUp = false;
									if(firstOpportunity === false) {
										nodeColors.push({id: nodesLeft[i].id, color: colors[currentColor]});
										nodesLeft.splice(i, 1);
										
										firstOpportunity = true;
									}
									else {
										newContext = copyGCContext(obj);
										newContext.currentColor = currentColor;
										newContext.nodeColors.push({id: newContext.nodesLeft[i].id, color: colors[newContext.currentColor]});
										newContext.nodesLeft.splice(i, 1);
										newContext.changeColor = false;
										self.postMessage(GCReport(newContext, "Incomplete"));
									}
								}								
							}
							
							//Update backup context
							obj = copyGCContext({nodeColors: nodeColors, nodesLeft: nodesLeft, currentColor: currentColor,
								changeColor: changeColor, matrix: matrix, GRAPH: JSON.stringify(GRAPH), colors: colors });
							firstOpportunity = false;
							
							//Give up on this color
							if (giveUp === true) {
								changeColor = true;
							}
						}
					}
					
					self.postMessage(GCReport(obj, "Complete"));
				}
			}
			
			function copyECContext(obj) {
				return {
					circuit: obj.circuit.slice(),
					edgesVisited: obj.edgesVisited.slice(),
					unusedEdges: obj.unusedEdges.slice(),
					start: obj.start,
					last:  obj.last,
					matrix: obj.matrix,
					GRAPH: obj.GRAPH
				};
			}
			
			function copyHCContext(obj) {
				return {
					circuit: obj.circuit.slice(),
					nodesVisited: obj.nodesVisited.slice(),
					matrix: obj.matrix,
					GRAPH: obj.GRAPH,
				};
			}
			
			function copyHPContext(obj) {
				return {
					path: obj.path.slice(),
					nodesVisited: obj.nodesVisited.slice(),
					matrix: obj.matrix,
					GRAPH: obj.GRAPH,
				};
			}
			
			function copyGCContext(obj) {
				return {
					nodeColors: obj.nodeColors.slice(),
					nodesLeft: obj.nodesLeft.slice(),
					currentColor: obj.currentColor,
					changeColor: obj.changeColor,
					matrix: obj.matrix,
					GRAPH: obj.GRAPH,
					colors: obj.colors
				};
			}
			
			function updateECContext(obj) {
				return {
					circuit: obj.circuit.slice(),
					edgesVisited: obj.edgesVisited.slice(),
					unusedEdges: obj.unusedEdges.slice(),
					start:  obj.start,
					last:  obj.last,
					matrix: obj.matrix,
					GRAPH: obj.GRAPH
				};
			}
			
			function ECReport(context, status) {
				return JSON.stringify({
					type: "EC",
					context: context,
					status: status
				});
			}
			
			function HCReport(context, status) {
				return JSON.stringify({
					type: "HC",
					context: context,
					status: status
				});
			}
			
			function HPReport(context, status) {
				return JSON.stringify({
					type: "HP",
					context: context,
					status: status
				});
			}
			
			function HPReport(context, status) {
				return JSON.stringify({
					type: "HP",
					context: context,
					status: status
				});
			}
			
			function GCReport(context, status) {
				return JSON.stringify({
					type: "GC",
					context: context,
					status: status
				});
			}
			
			function findIndexOfNode(nodes, id) {
				
				for(var i = 0; i < nodes.length; i++) {
					if(id == nodes[i].id) {
						return i;
					}
				}
				
				return null;
			}
			
			function compareDegrees(nodeA, nodeB) {
				if(nodeA.degree > nodeB.degree) {
					return -1;
				}
				else {
					return 1;
				}
			}
			
			function checkAdjNodesColor(node, nodes, matrix, color) {
				for(var i = 0; i < nodes.length; i++) {
					if(matrix[node.id][nodes[i].id] !== null &&
					color === nodes[i].color) {
						return false;
					}
				}
				
				return true;
			} 
			
		</script>
	
		<script src="../js/main.js"></script>
		
	</body>
</html>